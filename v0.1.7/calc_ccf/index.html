<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calculate CCFs · EchelleCCFs.jl</title><link rel="canonical" href="https://RvSpectML.github.io/EchelleCCFs.jl/calc_ccf/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="EchelleCCFs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">EchelleCCFs.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Calculate CCFs</a><ul class="internal"><li><a class="tocitem" href="#Calculate-CCFs-2"><span>Calculate CCFs</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li></ul></li><li><a class="tocitem" href="../calc_rv/">Calculate RVs</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../longlist/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Calculate CCFs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calculate CCFs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/master/docs/src/calc_ccf.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Calculate-CCFs"><a class="docs-heading-anchor" href="#Calculate-CCFs">Calculate CCFs</a><a id="Calculate-CCFs-1"></a><a class="docs-heading-anchor-permalink" href="#Calculate-CCFs" title="Permalink"></a></h1><ul><li><a href="#Calculate-CCFs">Calculate CCFs</a></li><ul><li><a href="#Calculate-CCFs-2">Calculate CCFs</a></li><ul><li><a href="#Functions">Functions</a></li><li><a href="#Types">Types</a></li></ul><li><a href="#Internals">Internals</a></li></ul></ul><h2 id="Calculate-CCFs-2"><a class="docs-heading-anchor" href="#Calculate-CCFs-2">Calculate CCFs</a><a class="docs-heading-anchor-permalink" href="#Calculate-CCFs-2" title="Permalink"></a></h2><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_var_chunk!-Union{Tuple{PlanT}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T3&lt;:Real where T2&lt;:Real where T1&lt;:Real" href="#EchelleCCFs.calc_ccf_and_var_chunk!-Union{Tuple{PlanT}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T3&lt;:Real where T2&lt;:Real where T1&lt;:Real"><code>EchelleCCFs.calc_ccf_and_var_chunk!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_var_chunk!( chunk, ccf_plan )</code> Convenience function to compute CCF and variance of each &quot;CCF pixel&quot; for one chunk of spectrum, evaluated using mask<em>shape and line list from `ccf</em>plan`.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>ccf_var_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>var</code>:  <code>AbstractArray</code> with variance to use for each pixel (overides value in chunk)</li><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Returns Named Tuple with:</strong></p><ul><li><code>ccf_out</code>:</li><li><code>ccf_var_out</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunk.jl#LL28-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_var_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T&lt;:Real" href="#EchelleCCFs.calc_ccf_and_var_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T&lt;:Real"><code>EchelleCCFs.calc_ccf_and_var_chunk</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_var_chunk( chunk, ccf_plan )</code> Convenience function to compute CCF and variance of each &quot;CCF pixel&quot; for one chunk of spectrum, evaluated using mask<em>shape and line list from `ccf</em>plan`.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>ccf_var_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>var</code>:  <code>AbstractArray</code> with variance to use for each pixel (overides value in chunk)</li></ul><p><code>-</code>assume<em>sorted`:  if true, skips checking the line</em>list is sorted by wavelength</p><p><strong>Returns Named Tuple with:</strong></p><ul><li><code>ccf_out</code>:</li><li><code>ccf_var_out</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunk.jl#LL102-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_var_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_ccf_and_var_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_ccf_and_var_chunklist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_var_chunklist ( chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunklist.jl#LL56-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_chunk!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractArray{T1,1},RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T2&lt;:Real where T1&lt;:Real" href="#EchelleCCFs.calc_ccf_chunk!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractArray{T1,1},RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T2&lt;:Real where T1&lt;:Real"><code>EchelleCCFs.calc_ccf_chunk!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_chunk!( cccf_out, chunk, ccf_plan )</code> Convenience function to compute CCF for one chunk of spectrum, evaluated using mask_shape and line list from ccf plan</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Returns:</strong></p><ul><li><code>ccf_out</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunk.jl#LL7-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T&lt;:Real" href="#EchelleCCFs.calc_ccf_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T&lt;:Real"><code>EchelleCCFs.calc_ccf_chunk</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_chunk( chunk, ccf_plan )</code> Convenience function to compute CCF for one chunk of spectrum.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li><li><code>calc_ccf_var</code>:  if true also computes estimate of variance for each value of ccf</li></ul><p><strong>Returns:</strong></p><ul><li>CCF for one chunk of spectrum, evaluated using mask_shape and line list from ccf plan</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunk.jl#LL77-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_ccf_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_ccf_chunklist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_chunklist ( chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunklist.jl#LL7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries,PlanT}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_ccf_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries,PlanT}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_ccf_chunklist_timeseries</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_chunklist_timeseries( chunklist_timeseries, line_list )</code> Convenience function to compute CCF for a timeseries of spectra, each with a chunklist. Uses multiple threads if avaliable.</p><p><strong>Inputs:</strong></p><ul><li>chunklist_timeseries</li></ul><p><strong>Optional Arguments:</strong></p><ul><li>ccf_plan (BasicCCFPlan())</li><li>verbose (false)</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the ccf<em>plan. Note that the ccf</em>plan provided is used as a template for creating a custom ccf<em>plan for each chunk that     only includes lines that reliably appear in that order for all spectra in the chunklist</em>timeseries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunklist_timeseries.jl#LL7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_template-Union{Tuple{A2}, Tuple{T2}} where A2&lt;:AbstractArray{T2,2} where T2&lt;:Real" href="#EchelleCCFs.calc_ccf_template-Union{Tuple{A2}, Tuple{T2}} where A2&lt;:AbstractArray{T2,2} where T2&lt;:Real"><code>EchelleCCFs.calc_ccf_template</code></a> — <span class="docstring-category">Method</span></header><section><div><p>calc<em>ccf</em>template( ccfs, [ccf<em>vars] ; assume</em>normalized = false ) Calculates ccf template Warning: uses maximum CCF for normalization, unless you normalize manually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/ccf_template.jl#LL42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_v_grid-Tuple{BasicCCFPlan}" href="#EchelleCCFs.calc_ccf_v_grid-Tuple{BasicCCFPlan}"><code>EchelleCCFs.calc_ccf_v_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_v_grid( plan )</code> Return range with 2n+1 points between -v<em>max and v</em>max where CCF is to be evaluated. Units based on those in plan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/plan.jl#LL41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_length_ccf_v_grid-Tuple{BasicCCFPlan}" href="#EchelleCCFs.calc_length_ccf_v_grid-Tuple{BasicCCFPlan}"><code>EchelleCCFs.calc_length_ccf_v_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_length_ccf_v_grid( plan )</code> Return number of points in the velocity grid (without needing to create the range).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/plan.jl#LL50-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_normalized_ccfs-Union{Tuple{A2}, Tuple{T2}} where A2&lt;:AbstractArray{T2,2} where T2&lt;:Real" href="#EchelleCCFs.calc_normalized_ccfs-Union{Tuple{A2}, Tuple{T2}} where A2&lt;:AbstractArray{T2,2} where T2&lt;:Real"><code>EchelleCCFs.calc_normalized_ccfs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>calc<em>normalized</em>ccfs( ccfs ) Normalizes each spectrum by its maximum value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/ccf_template.jl#LL28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccf_and_vars_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractArray{T1,2},AbstractArray{T1,2},RvSpectMLBase.AbstractChunkList}, Tuple{AbstractArray{T1,2},AbstractArray{T1,2},RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan where T1&lt;:Real" href="#EchelleCCFs.calc_order_ccf_and_vars_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractArray{T1,2},AbstractArray{T1,2},RvSpectMLBase.AbstractChunkList}, Tuple{AbstractArray{T1,2},AbstractArray{T1,2},RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan where T1&lt;:Real"><code>EchelleCCFs.calc_order_ccf_and_vars_chunklist!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccfs_chunklist ( chunklist_timeseries, list_of_ccf_plans )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) in a spectrum. CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk.</p><p><strong>Inputs:</strong></p><ul><li><code>chunklist_timeseries</code>:</li><li><code>list_of_ccf_plans</code>: ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>A 2-d array containing the CCF at each (velocity, chunk)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/order_ccf_chunklist.jl#LL60-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccf_and_vars_chunklist-Union{Tuple{RvSpectMLBase.AbstractChunkList}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_order_ccf_and_vars_chunklist-Union{Tuple{RvSpectMLBase.AbstractChunkList}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_order_ccf_and_vars_chunklist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccfs_chunklist ( chunklist_timeseries, list_of_ccf_plans )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) in a spectrum. CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk.</p><p><strong>Inputs:</strong></p><ul><li><code>chunklist_timeseries</code>:</li><li><code>list_of_ccf_plans</code>: ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>A 2-d array containing the CCF at each (velocity, chunk)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/order_ccf_chunklist.jl#LL88-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccfs_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractArray{T1,2},RvSpectMLBase.AbstractChunkList}, Tuple{AbstractArray{T1,2},RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan where T1&lt;:Real" href="#EchelleCCFs.calc_order_ccfs_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractArray{T1,2},RvSpectMLBase.AbstractChunkList}, Tuple{AbstractArray{T1,2},RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan where T1&lt;:Real"><code>EchelleCCFs.calc_order_ccfs_chunklist!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccfs_chunklist ( chunklist_timeseries, list_of_ccf_plans )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) in a spectrum. CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk.</p><p><strong>Inputs:</strong></p><ul><li><code>chunklist_timeseries</code>:</li><li><code>list_of_ccf_plans</code>: ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>A 2-d array containing the CCF at each (velocity, chunk)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/order_ccf_chunklist.jl#LL7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccfs_chunklist-Union{Tuple{RvSpectMLBase.AbstractChunkList}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_order_ccfs_chunklist-Union{Tuple{RvSpectMLBase.AbstractChunkList}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_order_ccfs_chunklist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccfs_chunklist ( chunklist_timeseries, list_of_ccf_plans )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) in a spectrum. CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk.</p><p><strong>Inputs:</strong></p><ul><li><code>chunklist_timeseries</code>:</li><li><code>list_of_ccf_plans</code>: ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>A 2-d array containing the CCF at each (velocity, chunk)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/order_ccf_chunklist.jl#LL36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1,A2,A3}, Tuple{A1,A2,A3,PlanT}} where PlanT&lt;:AbstractCCFPlan where T4&lt;:Real where A3&lt;:AbstractArray{T3,1} where T3&lt;:Real where A2&lt;:AbstractArray{T2,1} where T2&lt;:Real where A1&lt;:AbstractArray{T1,1} where T1&lt;:Real" href="#EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1,A2,A3}, Tuple{A1,A2,A3,PlanT}} where PlanT&lt;:AbstractCCFPlan where T4&lt;:Real where A3&lt;:AbstractArray{T3,1} where T3&lt;:Real where A2&lt;:AbstractArray{T2,1} where T2&lt;:Real where A1&lt;:AbstractArray{T1,1} where T1&lt;:Real"><code>EchelleCCFs.ccf_1D!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`ccf_1D!(ccf_out, λs, fluxes; ccf_plan )`</code></pre><p>Compute the cross correlation function of a spectrum with a mask.     Generalized version that should work with different mask shapes.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>: 1-d array of size length(calc<em>ccf</em>v_grid(plan)) to store output</li><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  1-d array of fluxes</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/calc_ccf.jl#LL10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T5}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1,A1,A2,A3,A4}, Tuple{A1,A1,A2,A3,A4,PlanT}} where PlanT&lt;:AbstractCCFPlan where T5&lt;:Real where A4&lt;:AbstractArray{T4,1} where T4&lt;:Real where A3&lt;:AbstractArray{T3,1} where T3&lt;:Real where A2&lt;:AbstractArray{T2,1} where T2&lt;:Real where A1&lt;:AbstractArray{T1,1} where T1&lt;:Real" href="#EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T5}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1,A1,A2,A3,A4}, Tuple{A1,A1,A2,A3,A4,PlanT}} where PlanT&lt;:AbstractCCFPlan where T5&lt;:Real where A4&lt;:AbstractArray{T4,1} where T4&lt;:Real where A3&lt;:AbstractArray{T3,1} where T3&lt;:Real where A2&lt;:AbstractArray{T2,1} where T2&lt;:Real where A1&lt;:AbstractArray{T1,1} where T1&lt;:Real"><code>EchelleCCFs.ccf_1D!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`ccf_1D!(ccf_out, ccf_var_out, λs, fluxes, var; ccf_plan )`</code></pre><p>Compute the cross correlation function of a spectrum with a mask.     Generalized version that should work with different mask shapes.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>: 1-d array of size length(calc<em>ccf</em>v_grid(plan)) to store output</li><li><code>ccf_var_out</code>:  1-d array of size length(calc<em>ccf</em>v_grid(plan)) to store output</li><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  1-d array of fluxes</li><li><code>var</code>:  1-d array of flux variances</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/calc_ccf.jl#LL54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T6}, Tuple{A5}, Tuple{T5}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1,A2,A3,A4,A5}, Tuple{A1,A2,A3,A4,A5,PlanT}} where PlanT&lt;:AbstractCCFPlan where T6&lt;:Real where A5&lt;:AbstractArray{T5,1} where T5&lt;:Real where A4&lt;:AbstractArray{T4,1} where T4&lt;:Real where A3&lt;:AbstractArray{T3,1} where T3&lt;:Real where A2&lt;:AbstractArray{T2,2} where T2&lt;:Real where A1&lt;:AbstractArray{T1,1} where T1&lt;:Real" href="#EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T6}, Tuple{A5}, Tuple{T5}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1,A2,A3,A4,A5}, Tuple{A1,A2,A3,A4,A5,PlanT}} where PlanT&lt;:AbstractCCFPlan where T6&lt;:Real where A5&lt;:AbstractArray{T5,1} where T5&lt;:Real where A4&lt;:AbstractArray{T4,1} where T4&lt;:Real where A3&lt;:AbstractArray{T3,1} where T3&lt;:Real where A2&lt;:AbstractArray{T2,2} where T2&lt;:Real where A1&lt;:AbstractArray{T1,1} where T1&lt;:Real"><code>EchelleCCFs.ccf_1D!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`ccf_1D!(ccf_out, ccf_covar_out, λs, fluxes, var; ccf_plan )`</code></pre><p>Compute the cross correlation function of a spectrum with a mask.     Generalized version that should work with different mask shapes.     WIP:  Generalized version to compute covariance matrix for ccf and optionally to account for LSF</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>: 1-d array of size length(calc<em>ccf</em>v_grid(plan)) to store output</li><li><code>ccf_covar_out</code>:  2-d array of size length(calc<em>ccf</em>v_grid(plan))^2 to store output</li><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  1-d array of fluxes</li><li><code>var</code>:  1-d array of flux variances</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/calc_ccf.jl#LL106-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2,A3}, Tuple{A2,A3,PlanT}} where PlanT&lt;:AbstractCCFPlan where A3&lt;:AbstractArray{T3,1} where T3&lt;:Real where A2&lt;:AbstractArray{T2,1} where T2&lt;:Real" href="#EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2,A3}, Tuple{A2,A3,PlanT}} where PlanT&lt;:AbstractCCFPlan where A3&lt;:AbstractArray{T3,1} where T3&lt;:Real where A2&lt;:AbstractArray{T2,1} where T2&lt;:Real"><code>EchelleCCFs.ccf_1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`ccf_1D( λs, fluxes; ccf_plan )`
Compute the cross correlation function of a spectrum with a mask.</code></pre><p><strong>Inputs:</strong></p><ul><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  1-d array of fluxes</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>ccf_plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul><p><strong>Returns:</strong></p><ul><li>1-d array of size length(calc<em>ccf</em>v_grid(plan))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/calc_ccf.jl#LL206-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2,A3}, Tuple{A2,A3,PlanT}} where PlanT&lt;:AbstractCCFPlan where A3&lt;:AbstractArray{T3,2} where T3&lt;:Real where A2&lt;:AbstractArray{T2,1} where T2&lt;:Real" href="#EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2,A3}, Tuple{A2,A3,PlanT}} where PlanT&lt;:AbstractCCFPlan where A3&lt;:AbstractArray{T3,2} where T3&lt;:Real where A2&lt;:AbstractArray{T2,1} where T2&lt;:Real"><code>EchelleCCFs.ccf_1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`ccf_1D( λs, fluxes; ccf_plan )`
Compute the cross correlation functions of spectra with a mask.</code></pre><p><strong>Inputs:</strong></p><ul><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  2-d array of fluxes, individual spectra along first dim</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>ccf_plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul><p><strong>Returns:</strong></p><ul><li>2-d array of size (length(calc<em>ccf</em>v_grid(plan)), size(flux, 2))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/calc_ccf.jl#LL233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2,A3,A4}, Tuple{A2,A3,A4,PlanT}} where PlanT&lt;:AbstractCCFPlan where A4&lt;:AbstractArray{T4,1} where T4&lt;:Real where A3&lt;:AbstractArray{T3,1} where T3&lt;:Real where A2&lt;:AbstractArray{T2,1} where T2&lt;:Real" href="#EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2,A3,A4}, Tuple{A2,A3,A4,PlanT}} where PlanT&lt;:AbstractCCFPlan where A4&lt;:AbstractArray{T4,1} where T4&lt;:Real where A3&lt;:AbstractArray{T3,1} where T3&lt;:Real where A2&lt;:AbstractArray{T2,1} where T2&lt;:Real"><code>EchelleCCFs.ccf_1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`ccf_1D( λs, fluxes, vars; ccf_plan )`</code></pre><p>Compute the cross correlation function of a spectrum with a mask and its variance^1. ^1 = This version computes the diagonal terms for the ccf variance and neglects covariances due to the line spread function. Can roughly compensate by scaling up the ccf<em>var</em>scale from the default of 1. WARNING: Still needs more testing.</p><p><strong>Inputs:</strong></p><ul><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  1-d array of fluxes</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>ccf_plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul><p><strong>Returns:</strong></p><ul><li>1-d array of size length(calc<em>ccf</em>v_grid(plan))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/calc_ccf.jl#LL264-L278">source</a></section></article><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.AbstractCCFMaskShape" href="#EchelleCCFs.AbstractCCFMaskShape"><code>EchelleCCFs.AbstractCCFMaskShape</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct implementing a specific mask shapes should be a subtype of AbstractCCFMaskShape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/mask_shapes.jl#LL20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.AbstractCCFPlan" href="#EchelleCCFs.AbstractCCFPlan"><code>EchelleCCFs.AbstractCCFPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct implementing a specific plans describing where the CCF is to be evaluated should be a subtype of AbstractCCFPlan. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/plan.jl#LL7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.AbstractLineList" href="#EchelleCCFs.AbstractLineList"><code>EchelleCCFs.AbstractLineList</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct implementing a line list should be a subtype of AbstractLineList. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/line_list/types.jl#LL7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.BasicCCFPlan" href="#EchelleCCFs.BasicCCFPlan"><code>EchelleCCFs.BasicCCFPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Basic plan for computing the CCF roughly between v<em>center-v</em>max and v<em>center+v</em>max with step size v_step. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/plan.jl#LL10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.BasicCCFPlan-Union{Tuple{}, Tuple{LLT}, Tuple{MST}} where LLT&lt;:AbstractLineList where MST&lt;:AbstractCCFMaskShape" href="#EchelleCCFs.BasicCCFPlan-Union{Tuple{}, Tuple{LLT}, Tuple{MST}} where LLT&lt;:AbstractLineList where MST&lt;:AbstractCCFMaskShape"><code>EchelleCCFs.BasicCCFPlan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>BasicCCFPlan</p><p><strong>Optional arguments:</strong></p><ul><li><code>midpoint</code>: (<code>default_v_center</code>)</li><li><code>step</code>: (<code>default_v_step</code>)</li><li><code>max</code>: (<code>default_v_max</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/plan.jl#LL29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.BasicLineList" href="#EchelleCCFs.BasicLineList"><code>EchelleCCFs.BasicLineList</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A basic line list for passing to compute CCFs. Contains (views into) arrays specifying the minimum and maximum wavelength range and weight for each line. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/line_list/types.jl#LL10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.BasicLineList-Union{Tuple{AA}, Tuple{T}, Tuple{AA,AA}} where AA&lt;:AbstractArray{T,1} where T&lt;:Real" href="#EchelleCCFs.BasicLineList-Union{Tuple{AA}, Tuple{T}, Tuple{AA,AA}} where AA&lt;:AbstractArray{T,1} where T&lt;:Real"><code>EchelleCCFs.BasicLineList</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>BasicLineList( λ, weight )</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/line_list/types.jl#LL17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.CosCCFMask" href="#EchelleCCFs.CosCCFMask"><code>EchelleCCFs.CosCCFMask</code></a> — <span class="docstring-category">Type</span></header><section><div><p>CosCCFMask Cosine mask with one parameter, it&#39;s quarter period, i.e., where to truncate it, as a velocity in m/s. Mask weights are stored separately in a line list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/halfcos.jl#LL7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.CosCCFMask-Tuple{Real}" href="#EchelleCCFs.CosCCFMask-Tuple{Real}"><code>EchelleCCFs.CosCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor for returning PSF for Δv &lt;= half_width.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/halfcos.jl#LL37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.CosCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}" href="#EchelleCCFs.CosCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}"><code>EchelleCCFs.CosCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>CosCCFMask( inst  )</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/halfcos.jl#LL23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.GaussianCCFMask" href="#EchelleCCFs.GaussianCCFMask"><code>EchelleCCFs.GaussianCCFMask</code></a> — <span class="docstring-category">Type</span></header><section><div><p>GaussianCCFMask A truncated Gaussian mask with two parameters, it&#39;s stdandard deviation and where to truncate it, both as a velocity in m/s. Mask weights are stored separately in a line list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/gaussian.jl#LL9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.GaussianCCFMask-Tuple{Real}" href="#EchelleCCFs.GaussianCCFMask-Tuple{Real}"><code>EchelleCCFs.GaussianCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor for returning PSF for Δv &lt;= half_width.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/gaussian.jl#LL53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.GaussianCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}" href="#EchelleCCFs.GaussianCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}"><code>EchelleCCFs.GaussianCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>GaussianCCFMask( inst ; scale_factor )</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/gaussian.jl#LL30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.SuperGaussianCCFMask" href="#EchelleCCFs.SuperGaussianCCFMask"><code>EchelleCCFs.SuperGaussianCCFMask</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SuperGaussianCCFMask A truncated Gaussian mask with two parameters, it&#39;s stdandard deviation and where to truncate it, both as a velocity in m/s. Mask weights are stored separately in a line list.</p><p>TODO: Repalce Gaussian with super-Gaussian Warning:  Not implemented/tested yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/supergaussian.jl#LL9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.SuperGaussianCCFMask-Tuple{InstT} where InstT&lt;:RvSpectMLBase.AbstractInstrument" href="#EchelleCCFs.SuperGaussianCCFMask-Tuple{InstT} where InstT&lt;:RvSpectMLBase.AbstractInstrument"><code>EchelleCCFs.SuperGaussianCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>SuperGaussianCCFMask( inst ; scale_factor )</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/supergaussian.jl#LL36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.SuperGaussianCCFMask-Tuple{Real}" href="#EchelleCCFs.SuperGaussianCCFMask-Tuple{Real}"><code>EchelleCCFs.SuperGaussianCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor for returning PSF for Δv &lt;= half_width.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/supergaussian.jl#LL52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.TopHatCCFMask" href="#EchelleCCFs.TopHatCCFMask"><code>EchelleCCFs.TopHatCCFMask</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TopHatCCFMask The standard tophat mask with one parameter, it&#39;s half width as a velocity in m/s. Mask weights are stored separately in a line list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/tophat.jl#LL7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.TopHatCCFMask" href="#EchelleCCFs.TopHatCCFMask"><code>EchelleCCFs.TopHatCCFMask</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>TopHatCCFMask( ; half_width=default_v_width )</code>` </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/tophat.jl#LL15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.TopHatCCFMask-Tuple{Real}" href="#EchelleCCFs.TopHatCCFMask-Tuple{Real}"><code>EchelleCCFs.TopHatCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor for returning constant for any Δv &lt;= width.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/tophat.jl#LL47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.TopHatCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}" href="#EchelleCCFs.TopHatCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}"><code>EchelleCCFs.TopHatCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>TopHatCCFMask( inst  )</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/mask_shapes/tophat.jl#LL21">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{AbstractLineList}" href="#Base.length-Tuple{AbstractLineList}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return length of line linst. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/line_list/types.jl#LL87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_covar_chunk!-Union{Tuple{PlanT}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},AbstractArray{T2,2},RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractArray{T1,1},AbstractArray{T2,2},RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T3&lt;:Real where T2&lt;:Real where T1&lt;:Real" href="#EchelleCCFs.calc_ccf_and_covar_chunk!-Union{Tuple{PlanT}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},AbstractArray{T2,2},RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractArray{T1,1},AbstractArray{T2,2},RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T3&lt;:Real where T2&lt;:Real where T1&lt;:Real"><code>EchelleCCFs.calc_ccf_and_covar_chunk!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_covar_chunk!( chunk, ccf_plan )</code> Convenience function to compute CCF and covariance of each pair of &quot;CCF pixels&quot; for one chunk of spectrum, evaluated using mask<em>shape and line list from `ccf</em>plan`.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>ccf_covar_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>var</code>:  <code>AbstractArray</code> with variance to use for each pixel (overides value in chunk)</li><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Returns Named Tuple with:</strong></p><ul><li><code>ccf_out</code>:</li><li><code>ccf_covar_out</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunk.jl#LL52-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_covar_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T&lt;:Real" href="#EchelleCCFs.calc_ccf_and_covar_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum,PlanT}} where PlanT&lt;:AbstractCCFPlan where T&lt;:Real"><code>EchelleCCFs.calc_ccf_and_covar_chunk</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_covar_chunk( chunk, ccf_plan )</code> Convenience function to compute CCF and covariance of each pair of &quot;CCF pixels&quot; for one chunk of spectrum, evaluated using mask<em>shape and line list from `ccf</em>plan`.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>ccf_covar_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>var</code>:  <code>AbstractArray</code> with variance to use for each pixel (overides value in chunk)</li></ul><p><code>-</code>assume<em>sorted`:  if true, skips checking the line</em>list is sorted by wavelength</p><p><strong>Returns Named Tuple with:</strong></p><ul><li><code>ccf_out</code>:</li><li><code>ccf_covar_out</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunk.jl#LL127-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_covar_chunklist!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},AbstractArray{T2,2},RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan where T2&lt;:Real where T1&lt;:Real" href="#EchelleCCFs.calc_ccf_and_covar_chunklist!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},AbstractArray{T2,2},RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan where T2&lt;:Real where T1&lt;:Real"><code>EchelleCCFs.calc_ccf_and_covar_chunklist!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_covar_chunklist! ( ccf_out, ccf_cocovar_out, chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunklist.jl#LL124-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_covar_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_ccf_and_covar_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_ccf_and_covar_chunklist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_covar_chunklist ( chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunklist.jl#LL163-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_var_chunklist!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan where T2&lt;:Real where T1&lt;:Real" href="#EchelleCCFs.calc_ccf_and_var_chunklist!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan where T2&lt;:Real where T1&lt;:Real"><code>EchelleCCFs.calc_ccf_and_var_chunklist!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_var_chunklist! ( ccf_out, ccf_var_out, chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunklist.jl#LL85-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractArray{T1,1},RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan where T1&lt;:Real" href="#EchelleCCFs.calc_ccf_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractArray{T1,1},RvSpectMLBase.AbstractChunkList,AbstractArray{PlanT,1}}} where PlanT&lt;:AbstractCCFPlan where T1&lt;:Real"><code>EchelleCCFs.calc_ccf_chunklist!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_chunklist! ( ccfs_out, chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/ccf_chunklist.jl#LL28-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_doppler_factor-Tuple{Real}" href="#EchelleCCFs.calc_doppler_factor-Tuple{Real}"><code>EchelleCCFs.calc_doppler_factor</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_doppler_factor(vel)</code>` Compute the longitudinal relativistic doppler factor given a velocity in meters per second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/physics.jl#LL12-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccf_and_var_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries,PlanT}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_order_ccf_and_var_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries,PlanT}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_order_ccf_and_var_chunklist_timeseries</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccf_chunklist_timeseries( chunklist_timeseries, ccf_plan )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) of each spectrum in a timeseries.     CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk. Uses multiple threads if avaliable.</p><p><strong>Inputs:</strong></p><ul><li>chunklist_timeseries</li></ul><p><strong>Optional Arguments:</strong></p><ul><li>ccf_plan (BasicCCFPlan())</li></ul><p><strong>Return:</strong></p><p>A 3-d array containing the CCF at each (velocity, chunk, spectrum) Note that the ccf<em>plan provided is used as a template for creating a custom ccf</em>plan for each chunk that     only includes lines that reliably appear in that order for all spectra in the chunklist_timeseries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/order_ccf_chunklist_timeseries.jl#LL102-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccf_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries,PlanT}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_order_ccf_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries,PlanT}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_order_ccf_chunklist_timeseries</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccf_chunklist_timeseries( chunklist_timeseries, ccf_plan )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) of each spectrum in a timeseries.     CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk. Uses multiple threads if avaliable.</p><p><strong>Inputs:</strong></p><ul><li>chunklist_timeseries</li></ul><p><strong>Optional Arguments:</strong></p><ul><li>ccf_plan (BasicCCFPlan())</li></ul><p><strong>Return:</strong></p><p>A 3-d array containing the CCF at each (velocity, chunk, spectrum) Note that the ccf<em>plan provided is used as a template for creating a custom ccf</em>plan for each chunk that     only includes lines that reliably appear in that order for all spectra in the chunklist_timeseries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/convenience/order_ccf_chunklist_timeseries.jl#LL8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.find_overlapping_chunks-Tuple{DataFrames.DataFrame}" href="#EchelleCCFs.find_overlapping_chunks-Tuple{DataFrames.DataFrame}"><code>EchelleCCFs.find_overlapping_chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return indices of any chunks in df that have overlapping <code>lambda_hi[i]</code> and <code>lambda_lo[i+1]</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/masks/masks.jl#LL69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.fit_ccf_normalizations-Union{Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1,A2}} where A2&lt;:AbstractArray{T2,2} where T2&lt;:Real where A1&lt;:AbstractArray{T1,1} where T1&lt;:Real" href="#EchelleCCFs.fit_ccf_normalizations-Union{Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1,A2}} where A2&lt;:AbstractArray{T2,2} where T2&lt;:Real where A1&lt;:AbstractArray{T1,1} where T1&lt;:Real"><code>EchelleCCFs.fit_ccf_normalizations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>calc<em>normalized</em>ccfs( ccfs ) Normalizes each spectrum by fitting a line to the region outside the center</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/ccf_template.jl#LL8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.merge_chunks-Tuple{DataFrames.DataFrame}" href="#EchelleCCFs.merge_chunks-Tuple{DataFrames.DataFrame}"><code>EchelleCCFs.merge_chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return DataFrame with specifications for each chunk which will contain one or more lines. Input:  <code>line_list</code> a DataFrame with:     - <code>lambda_lo</code>, <code>lambda_hi</code>, <code>lambda</code>, <code>depth</code>     Output:  DataFrame with     - <code>lambda_lo</code> &amp; <code>lambda_hi</code>: boundaries for chunk     - <code>lambda</code> &amp; <code>line_depths</code>: arrays with info about each line</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/masks/masks.jl#LL83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.project_mask!-Union{Tuple{PlanT}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A2,A1,PlanT}} where PlanT&lt;:AbstractCCFPlan where A2&lt;:AbstractArray{T2,2} where T2&lt;:Real where A1&lt;:AbstractArray{T1,1} where T1&lt;:Real" href="#EchelleCCFs.project_mask!-Union{Tuple{PlanT}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A2,A1,PlanT}} where PlanT&lt;:AbstractCCFPlan where A2&lt;:AbstractArray{T2,2} where T2&lt;:Real where A1&lt;:AbstractArray{T1,1} where T1&lt;:Real"><code>EchelleCCFs.project_mask!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>project_mask!( output, λs, ccf_plan; shift_factor )</code></p><p>Compute the projection of the mask onto the 1D array of wavelengths (λs) at a given shift factor (default: 1). The mask is computed from the ccf<em>plan, including a line</em>list and mask<em>shape (default: tophat). Assumes plan.line</em>list is already sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/ccf/calc_ccf.jl#LL303-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.read_linelist_espresso-Tuple{String}" href="#EchelleCCFs.read_linelist_espresso-Tuple{String}"><code>EchelleCCFs.read_linelist_espresso</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Read line list in ESPRESSO csv format.</code></pre><p>ESPRESSO format: lambda and weight. Warning: ESPRESSO masks don&#39;t provide line depth and sometimes include one entry for a blend of lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/masks/io.jl#LL8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.read_linelist_rvspectml-Tuple{String}" href="#EchelleCCFs.read_linelist_rvspectml-Tuple{String}"><code>EchelleCCFs.read_linelist_rvspectml</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read line list in csv format.    format: lambda, weight, lambda<em>lo, lambdaa</em>hi.    Assumes air to vacuumb wavelength conversion has already been applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/masks/io.jl#LL33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.read_linelist_vald-Tuple{String}" href="#EchelleCCFs.read_linelist_vald-Tuple{String}"><code>EchelleCCFs.read_linelist_vald</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read line list in VALD csv format.    VALD format: lambda<em>lo, lambdaa</em>hi and depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/masks/io.jl#LL21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.read_mask_espresso-Union{Tuple{String}, Tuple{CCWT}} where CCWT&lt;:EchelleCCFs.AbstractCalcChunkWidth" href="#EchelleCCFs.read_mask_espresso-Union{Tuple{String}, Tuple{CCWT}} where CCWT&lt;:EchelleCCFs.AbstractCalcChunkWidth"><code>EchelleCCFs.read_mask_espresso</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Read mask in ESPRESSO csv format.</code></pre><p>ESPRESSO format: <code>lambda</code> and <code>weight</code>. Warning: ESPRESSO masks don&#39;t provide line depth and sometimes include one entry for a blend of lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/masks/masks.jl#LL38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.read_mask_vald-Union{Tuple{String}, Tuple{CCWT}} where CCWT&lt;:EchelleCCFs.AbstractCalcChunkWidth" href="#EchelleCCFs.read_mask_vald-Union{Tuple{String}, Tuple{CCWT}} where CCWT&lt;:EchelleCCFs.AbstractCalcChunkWidth"><code>EchelleCCFs.read_mask_vald</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read mask in VALD csv format.    VALD format: <code>lambda_lo</code>, <code>lambdaa_hi</code> and <code>depth</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/masks/masks.jl#LL54-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.λ_air_to_vac-Tuple{Real}" href="#EchelleCCFs.λ_air_to_vac-Tuple{Real}"><code>EchelleCCFs.λ_air_to_vac</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert air wavelength (in Å) to vacuum wavelength Ref: https://www.astro.uu.se/valdwiki/Air-to-vacuum%20conversion      VALD3 tools use the following solution derived by N. Piskunov</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/physics.jl#LL39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.λ_vac_to_air-Tuple{Real}" href="#EchelleCCFs.λ_vac_to_air-Tuple{Real}"><code>EchelleCCFs.λ_vac_to_air</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert vacuum wavelength (in Å) to air wavelength Ref: Donald Morton (2000, ApJ. Suppl., 130, 403) via      https://www.astro.uu.se/valdwiki/Air-to-vacuum%20conversion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/de91ee4d3ad19fb1c7be655258aecf694e61cb46/src/physics.jl#LL28-L32">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../calc_rv/">Calculate RVs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 18 December 2020 07:07">Friday 18 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
