<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calculate CCFs · EchelleCCFs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://RvSpectML.github.io/EchelleCCFs.jl/calc_ccf/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="EchelleCCFs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">EchelleCCFs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Calculate CCFs</a><ul class="internal"><li><a class="tocitem" href="#Calculate-CCFs-2"><span>Calculate CCFs</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li></ul></li><li><a class="tocitem" href="../calc_rv/">Calculate RVs</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../longlist/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Calculate CCFs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calculate CCFs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/main/docs/src/calc_ccf.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Calculate-CCFs"><a class="docs-heading-anchor" href="#Calculate-CCFs">Calculate CCFs</a><a id="Calculate-CCFs-1"></a><a class="docs-heading-anchor-permalink" href="#Calculate-CCFs" title="Permalink"></a></h1><ul><li><a href="#Calculate-CCFs">Calculate CCFs</a></li><li class="no-marker"><ul><li><a href="#Calculate-CCFs-2">Calculate CCFs</a></li><li class="no-marker"><ul><li><a href="#Functions">Functions</a></li><li><a href="#Types">Types</a></li></ul></li><li><a href="#Internals">Internals</a></li></ul></li></ul><h2 id="Calculate-CCFs-2"><a class="docs-heading-anchor" href="#Calculate-CCFs-2">Calculate CCFs</a><a class="docs-heading-anchor-permalink" href="#Calculate-CCFs-2" title="Permalink"></a></h2><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_var_chunk!-Union{Tuple{PlanT}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}, RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractVector{T1}, AbstractVector{T2}, RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_ccf_and_var_chunk!-Union{Tuple{PlanT}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}, RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractVector{T1}, AbstractVector{T2}, RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_ccf_and_var_chunk!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_var_chunk!( chunk, ccf_plan )</code> Convenience function to compute CCF and variance of each &quot;CCF pixel&quot; for one chunk of spectrum, evaluated using mask<em>shape and line list from `ccf</em>plan`.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>ccf_var_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>var</code>:  <code>AbstractArray</code> with variance to use for each pixel (overides value in chunk)</li><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Returns Named Tuple with:</strong></p><ul><li><code>ccf_out</code>:</li><li><code>ccf_var_out</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunk.jl#LL28-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_var_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_ccf_and_var_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_ccf_and_var_chunk</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_var_chunk( chunk, ccf_plan )</code> Convenience function to compute CCF and variance of each &quot;CCF pixel&quot; for one chunk of spectrum, evaluated using mask<em>shape and line list from `ccf</em>plan`.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>ccf_var_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>var</code>:  <code>AbstractArray</code> with variance to use for each pixel (overides value in chunk)</li></ul><p><code>-</code>assume<em>sorted`:  if true, skips checking the line</em>list is sorted by wavelength</p><p><strong>Returns Named Tuple with:</strong></p><ul><li><code>ccf_out</code>:</li><li><code>ccf_var_out</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunk.jl#LL108-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_var_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_ccf_and_var_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_ccf_and_var_chunklist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_var_chunklist ( chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunklist.jl#LL66-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_chunk!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractVector{T1}, RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T1&lt;:Real, T2&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_ccf_chunk!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractVector{T1}, RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T1&lt;:Real, T2&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_ccf_chunk!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_chunk!( ccf_out, chunk, ccf_plan )</code> Convenience function to compute CCF for one chunk of spectrum, evaluated using mask_shape and line list from ccf plan</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Returns:</strong></p><ul><li><code>ccf_out</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunk.jl#LL7-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_ccf_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_ccf_chunk</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_chunk( chunk, ccf_plan )</code> Convenience function to compute CCF for one chunk of spectrum.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li><li><code>calc_ccf_var</code>:  if true also computes estimate of variance for each value of ccf</li></ul><p><strong>Returns:</strong></p><ul><li>CCF for one chunk of spectrum, evaluated using mask_shape and line list from ccf plan</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunk.jl#LL77-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_ccf_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_ccf_chunklist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_chunklist ( chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunklist.jl#LL7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{T}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries, PlanT}} where {PlanT&lt;:AbstractCCFPlan, T&lt;:Real}" href="#EchelleCCFs.calc_ccf_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{T}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries, PlanT}} where {PlanT&lt;:AbstractCCFPlan, T&lt;:Real}"><code>EchelleCCFs.calc_ccf_chunklist_timeseries</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_chunklist_timeseries( chunklist_timeseries, line_list )</code> Convenience function to compute CCF for a timeseries of spectra, each with a chunklist. Uses multiple threads if avaliable.</p><p><strong>Inputs:</strong></p><ul><li>chunklist_timeseries</li></ul><p><strong>Optional Arguments:</strong></p><ul><li>ccf_plan (BasicCCFPlan())</li><li>verbose (false)</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the ccf<em>plan. Note that the ccf</em>plan provided is used as a template for creating a custom ccf<em>plan for each chunk that     only includes lines that reliably appear in that order for all spectra in the chunklist</em>timeseries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunklist_timeseries.jl#LL7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_template-Union{Tuple{A2}, Tuple{T2}} where {T2&lt;:Real, A2&lt;:AbstractMatrix{T2}}" href="#EchelleCCFs.calc_ccf_template-Union{Tuple{A2}, Tuple{T2}} where {T2&lt;:Real, A2&lt;:AbstractMatrix{T2}}"><code>EchelleCCFs.calc_ccf_template</code></a> — <span class="docstring-category">Method</span></header><section><div><p>calc<em>ccf</em>template( ccfs, [ccf<em>vars] ; assume</em>normalized = false ) Calculates ccf template Warning: uses maximum CCF for normalization, unless you normalize manually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/ccf_template.jl#LL53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_v_grid-Tuple{BasicCCFPlan}" href="#EchelleCCFs.calc_ccf_v_grid-Tuple{BasicCCFPlan}"><code>EchelleCCFs.calc_ccf_v_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_v_grid( plan )</code> Return range where CCF is to be evaluated, Centered around plan.v<em>center going up to at least plan.v</em>max in steps of size plan.v_step. Units based on those in plan.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/plan.jl#LL42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_length_ccf_v_grid-Tuple{BasicCCFPlan}" href="#EchelleCCFs.calc_length_ccf_v_grid-Tuple{BasicCCFPlan}"><code>EchelleCCFs.calc_length_ccf_v_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_length_ccf_v_grid( plan )</code> Return number of points in the velocity grid (without needing to create the range).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/plan.jl#LL53-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_normalized_ccfs-Union{Tuple{A2}, Tuple{T2}} where {T2&lt;:Real, A2&lt;:AbstractMatrix{T2}}" href="#EchelleCCFs.calc_normalized_ccfs-Union{Tuple{A2}, Tuple{T2}} where {T2&lt;:Real, A2&lt;:AbstractMatrix{T2}}"><code>EchelleCCFs.calc_normalized_ccfs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>calc<em>normalized</em>ccfs( ccfs ) Normalizes each spectrum by its maximum value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/ccf_template.jl#LL39-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccf_and_vars_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractMatrix{T1}, AbstractMatrix{T1}, RvSpectMLBase.AbstractChunkList}, Tuple{AbstractMatrix{T1}, AbstractMatrix{T1}, RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where {T1&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_order_ccf_and_vars_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractMatrix{T1}, AbstractMatrix{T1}, RvSpectMLBase.AbstractChunkList}, Tuple{AbstractMatrix{T1}, AbstractMatrix{T1}, RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where {T1&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_order_ccf_and_vars_chunklist!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccfs_chunklist ( chunklist_timeseries, list_of_ccf_plans )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) in a spectrum. CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk.</p><p><strong>Inputs:</strong></p><ul><li><code>chunklist_timeseries</code>:</li><li><code>list_of_ccf_plans</code>: ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>A 2-d array containing the CCF at each (velocity, chunk)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/order_ccf_chunklist.jl#LL69-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccf_and_vars_chunklist-Union{Tuple{RvSpectMLBase.AbstractChunkList}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_order_ccf_and_vars_chunklist-Union{Tuple{RvSpectMLBase.AbstractChunkList}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_order_ccf_and_vars_chunklist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccfs_chunklist ( chunklist_timeseries, list_of_ccf_plans )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) in a spectrum. CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk.</p><p><strong>Inputs:</strong></p><ul><li><code>chunklist_timeseries</code>:</li><li><code>list_of_ccf_plans</code>: ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>A 2-d array containing the CCF at each (velocity, chunk)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/order_ccf_chunklist.jl#LL97-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccfs_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractMatrix{T1}, RvSpectMLBase.AbstractChunkList}, Tuple{AbstractMatrix{T1}, RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where {T1&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_order_ccfs_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractMatrix{T1}, RvSpectMLBase.AbstractChunkList}, Tuple{AbstractMatrix{T1}, RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where {T1&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_order_ccfs_chunklist!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccfs_chunklist ( chunklist_timeseries, list_of_ccf_plans )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) in a spectrum. CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk.</p><p><strong>Inputs:</strong></p><ul><li><code>chunklist_timeseries</code>:</li><li><code>list_of_ccf_plans</code>: ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>A 2-d array containing the CCF at each (velocity, chunk)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/order_ccf_chunklist.jl#LL7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccfs_chunklist-Union{Tuple{RvSpectMLBase.AbstractChunkList}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_order_ccfs_chunklist-Union{Tuple{RvSpectMLBase.AbstractChunkList}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_order_ccfs_chunklist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccfs_chunklist ( chunklist_timeseries, list_of_ccf_plans )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) in a spectrum. CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk.</p><p><strong>Inputs:</strong></p><ul><li><code>chunklist_timeseries</code>:</li><li><code>list_of_ccf_plans</code>: ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>A 2-d array containing the CCF at each (velocity, chunk)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/order_ccf_chunklist.jl#LL36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1, A2, A3}, Tuple{A1, A2, A3, PlanT}} where {T1&lt;:Real, A1&lt;:AbstractVector{T1}, T2&lt;:Real, A2&lt;:AbstractVector{T2}, T3&lt;:Real, A3&lt;:AbstractVector{T3}, T4&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1, A2, A3}, Tuple{A1, A2, A3, PlanT}} where {T1&lt;:Real, A1&lt;:AbstractVector{T1}, T2&lt;:Real, A2&lt;:AbstractVector{T2}, T3&lt;:Real, A3&lt;:AbstractVector{T3}, T4&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.ccf_1D!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`ccf_1D!(ccf_out, λs, fluxes; ccf_plan )`</code></pre><p>Compute the cross correlation function of a spectrum with a mask.     Generalized version that should work with different mask shapes.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>: 1-d array of size length(calc<em>ccf</em>v_grid(plan)) to store output</li><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  1-d array of fluxes</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/calc_ccf.jl#LL10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T5}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1, A1, A2, A3, A4}, Tuple{A1, A1, A2, A3, A4, PlanT}} where {T1&lt;:Real, A1&lt;:AbstractVector{T1}, T2&lt;:Real, A2&lt;:AbstractVector{T2}, T3&lt;:Real, A3&lt;:AbstractVector{T3}, T4&lt;:Real, A4&lt;:AbstractVector{T4}, T5&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T5}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1, A1, A2, A3, A4}, Tuple{A1, A1, A2, A3, A4, PlanT}} where {T1&lt;:Real, A1&lt;:AbstractVector{T1}, T2&lt;:Real, A2&lt;:AbstractVector{T2}, T3&lt;:Real, A3&lt;:AbstractVector{T3}, T4&lt;:Real, A4&lt;:AbstractVector{T4}, T5&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.ccf_1D!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`ccf_1D!(ccf_out, ccf_var_out, λs, fluxes, var; ccf_plan )`</code></pre><p>Compute the cross correlation function of a spectrum with a mask.     Generalized version that should work with different mask shapes.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>: 1-d array of size length(calc<em>ccf</em>v_grid(plan)) to store output</li><li><code>ccf_var_out</code>:  1-d array of size length(calc<em>ccf</em>v_grid(plan)) to store output</li><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  1-d array of fluxes</li><li><code>var</code>:  1-d array of flux variances</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/calc_ccf.jl#LL54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T6}, Tuple{A5}, Tuple{T5}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1, A2, A3, A4, A5}, Tuple{A1, A2, A3, A4, A5, PlanT}} where {T1&lt;:Real, A1&lt;:AbstractVector{T1}, T2&lt;:Real, A2&lt;:AbstractMatrix{T2}, T3&lt;:Real, A3&lt;:AbstractVector{T3}, T4&lt;:Real, A4&lt;:AbstractVector{T4}, T5&lt;:Real, A5&lt;:AbstractVector{T5}, T6&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.ccf_1D!-Union{Tuple{PlanT}, Tuple{T6}, Tuple{A5}, Tuple{T5}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1, A2, A3, A4, A5}, Tuple{A1, A2, A3, A4, A5, PlanT}} where {T1&lt;:Real, A1&lt;:AbstractVector{T1}, T2&lt;:Real, A2&lt;:AbstractMatrix{T2}, T3&lt;:Real, A3&lt;:AbstractVector{T3}, T4&lt;:Real, A4&lt;:AbstractVector{T4}, T5&lt;:Real, A5&lt;:AbstractVector{T5}, T6&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.ccf_1D!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`ccf_1D!(ccf_out, ccf_covar_out, λs, fluxes, var; ccf_plan )`</code></pre><p>Compute the cross correlation function of a spectrum with a mask.     Generalized version that should work with different mask shapes.     WIP:  Generalized version to compute covariance matrix for ccf and optionally to account for LSF</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>: 1-d array of size length(calc<em>ccf</em>v_grid(plan)) to store output</li><li><code>ccf_covar_out</code>:  2-d array of size length(calc<em>ccf</em>v_grid(plan))^2 to store output</li><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  1-d array of fluxes</li><li><code>var</code>:  1-d array of flux variances</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/calc_ccf.jl#LL107-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2, A3}, Tuple{A2, A3, PlanT}} where {T2&lt;:Real, A2&lt;:AbstractVector{T2}, T3&lt;:Real, A3&lt;:AbstractMatrix{T3}, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2, A3}, Tuple{A2, A3, PlanT}} where {T2&lt;:Real, A2&lt;:AbstractVector{T2}, T3&lt;:Real, A3&lt;:AbstractMatrix{T3}, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.ccf_1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`ccf_1D( λs, fluxes; ccf_plan )`
Compute the cross correlation functions of spectra with a mask.</code></pre><p><strong>Inputs:</strong></p><ul><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  2-d array of fluxes, individual spectra along first dim</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>ccf_plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul><p><strong>Returns:</strong></p><ul><li>2-d array of size (length(calc<em>ccf</em>v_grid(plan)), size(flux, 2))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/calc_ccf.jl#LL234-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2, A3}, Tuple{A2, A3, PlanT}} where {T2&lt;:Real, A2&lt;:AbstractVector{T2}, T3&lt;:Real, A3&lt;:AbstractVector{T3}, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2, A3}, Tuple{A2, A3, PlanT}} where {T2&lt;:Real, A2&lt;:AbstractVector{T2}, T3&lt;:Real, A3&lt;:AbstractVector{T3}, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.ccf_1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`ccf_1D( λs, fluxes; ccf_plan )`
Compute the cross correlation function of a spectrum with a mask.</code></pre><p><strong>Inputs:</strong></p><ul><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  1-d array of fluxes</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>ccf_plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul><p><strong>Returns:</strong></p><ul><li>1-d array of size length(calc<em>ccf</em>v_grid(plan))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/calc_ccf.jl#LL207-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2, A3, A4}, Tuple{A2, A3, A4, PlanT}} where {T2&lt;:Real, A2&lt;:AbstractVector{T2}, T3&lt;:Real, A3&lt;:AbstractVector{T3}, T4&lt;:Real, A4&lt;:AbstractVector{T4}, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.ccf_1D-Union{Tuple{PlanT}, Tuple{A4}, Tuple{T4}, Tuple{A3}, Tuple{T3}, Tuple{A2}, Tuple{T2}, Tuple{A2, A3, A4}, Tuple{A2, A3, A4, PlanT}} where {T2&lt;:Real, A2&lt;:AbstractVector{T2}, T3&lt;:Real, A3&lt;:AbstractVector{T3}, T4&lt;:Real, A4&lt;:AbstractVector{T4}, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.ccf_1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`ccf_1D( λs, fluxes, vars; ccf_plan )`</code></pre><p>Compute the cross correlation function of a spectrum with a mask and its variance^1. ^1 = This version computes the diagonal terms for the ccf variance and neglects covariances due to the line spread function. Can roughly compensate by scaling up the ccf<em>var</em>scale from the default of 1. WARNING: Still needs more testing.</p><p><strong>Inputs:</strong></p><ul><li><code>λs</code>: 1-d array of wavelengths</li><li><code>fluxes</code>:  1-d array of fluxes</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>ccf_plan</code>:  parameters for computing ccf (BasicCCFPlan())</li></ul><p><strong>Returns:</strong></p><ul><li>1-d array of size length(calc<em>ccf</em>v_grid(plan))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/calc_ccf.jl#LL265-L279">source</a></section></article><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.AbstractCCFMaskShape" href="#EchelleCCFs.AbstractCCFMaskShape"><code>EchelleCCFs.AbstractCCFMaskShape</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct implementing a specific mask shapes should be a subtype of AbstractCCFMaskShape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/mask_shapes.jl#LL20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.AbstractCCFPlan" href="#EchelleCCFs.AbstractCCFPlan"><code>EchelleCCFs.AbstractCCFPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct implementing a specific plans describing where the CCF is to be evaluated should be a subtype of AbstractCCFPlan. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/plan.jl#LL7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.AbstractLineList" href="#EchelleCCFs.AbstractLineList"><code>EchelleCCFs.AbstractLineList</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct implementing a line list should be a subtype of AbstractLineList. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/line_list/types.jl#LL7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.BasicCCFPlan" href="#EchelleCCFs.BasicCCFPlan"><code>EchelleCCFs.BasicCCFPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Basic plan for computing the CCF roughly between v<em>center-v</em>max and v<em>center+v</em>max with step size v_step. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/plan.jl#LL10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.BasicCCFPlan-Union{Tuple{}, Tuple{LLT}, Tuple{MST}} where {MST&lt;:AbstractCCFMaskShape, LLT&lt;:AbstractLineList}" href="#EchelleCCFs.BasicCCFPlan-Union{Tuple{}, Tuple{LLT}, Tuple{MST}} where {MST&lt;:AbstractCCFMaskShape, LLT&lt;:AbstractLineList}"><code>EchelleCCFs.BasicCCFPlan</code></a> — <span class="docstring-category">Method</span></header><section><div><p>BasicCCFPlan</p><p><strong>Optional arguments:</strong></p><ul><li><code>midpoint</code>: (<code>default_v_center</code>)</li><li><code>step</code>: (<code>default_v_step</code>)</li><li><code>max</code>: (<code>default_v_max</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/plan.jl#LL30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.BasicLineList" href="#EchelleCCFs.BasicLineList"><code>EchelleCCFs.BasicLineList</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A basic line list for passing to compute CCFs. Contains (views into) arrays specifying the minimum and maximum wavelength range and weight for each line. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/line_list/types.jl#LL10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.BasicLineList-Union{Tuple{AA}, Tuple{T}, Tuple{AA, AA}} where {T&lt;:Real, AA&lt;:AbstractVector{T}}" href="#EchelleCCFs.BasicLineList-Union{Tuple{AA}, Tuple{T}, Tuple{AA, AA}} where {T&lt;:Real, AA&lt;:AbstractVector{T}}"><code>EchelleCCFs.BasicLineList</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>BasicLineList( λ, weight )</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/line_list/types.jl#LL17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.CosCCFMask" href="#EchelleCCFs.CosCCFMask"><code>EchelleCCFs.CosCCFMask</code></a> — <span class="docstring-category">Type</span></header><section><div><p>CosCCFMask Cosine mask with one parameter, it&#39;s quarter period, i.e., where to truncate it, as a velocity in m/s. Mask weights are stored separately in a line list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/halfcos.jl#LL7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.CosCCFMask-Tuple{Real}" href="#EchelleCCFs.CosCCFMask-Tuple{Real}"><code>EchelleCCFs.CosCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor for returning PSF for Δv &lt;= half_width.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/halfcos.jl#LL36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.CosCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}" href="#EchelleCCFs.CosCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}"><code>EchelleCCFs.CosCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>CosCCFMask( inst  )</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/halfcos.jl#LL22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.GaussianCCFMask" href="#EchelleCCFs.GaussianCCFMask"><code>EchelleCCFs.GaussianCCFMask</code></a> — <span class="docstring-category">Type</span></header><section><div><p>GaussianCCFMask A truncated Gaussian mask with two parameters, its standard deviation and where to truncate it, both as a velocity in m/s. Mask weights are stored separately in a line list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/gaussian.jl#LL9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.GaussianCCFMask-Tuple{Real}" href="#EchelleCCFs.GaussianCCFMask-Tuple{Real}"><code>EchelleCCFs.GaussianCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor for returning PSF for Δv &lt;= half_width.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/gaussian.jl#LL54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.GaussianCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}" href="#EchelleCCFs.GaussianCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}"><code>EchelleCCFs.GaussianCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>GaussianCCFMask( inst ; scale_factor )</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/gaussian.jl#LL31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.SuperGaussianCCFMask" href="#EchelleCCFs.SuperGaussianCCFMask"><code>EchelleCCFs.SuperGaussianCCFMask</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SuperGaussianCCFMask A truncated Gaussian mask with two parameters, its standard deviation and where to truncate it, both as a velocity in m/s. Mask weights are stored separately in a line list.</p><p>TODO: Replace Gaussian with super-Gaussian Warning:  Not implemented/tested yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/supergaussian.jl#LL9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.SuperGaussianCCFMask-Tuple{InstT} where InstT&lt;:RvSpectMLBase.AbstractInstrument" href="#EchelleCCFs.SuperGaussianCCFMask-Tuple{InstT} where InstT&lt;:RvSpectMLBase.AbstractInstrument"><code>EchelleCCFs.SuperGaussianCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>SuperGaussianCCFMask( inst ; scale_factor )</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/supergaussian.jl#LL36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.SuperGaussianCCFMask-Tuple{Real}" href="#EchelleCCFs.SuperGaussianCCFMask-Tuple{Real}"><code>EchelleCCFs.SuperGaussianCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor for returning PSF for Δv &lt;= half_width.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/supergaussian.jl#LL52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.TopHatCCFMask" href="#EchelleCCFs.TopHatCCFMask"><code>EchelleCCFs.TopHatCCFMask</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>TopHatCCFMask( full_width )</code>` </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/tophat.jl#LL15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.TopHatCCFMask" href="#EchelleCCFs.TopHatCCFMask"><code>EchelleCCFs.TopHatCCFMask</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TopHatCCFMask The standard tophat mask with one parameter, it&#39;s half width as a velocity in m/s. Mask weights are stored separately in a line list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/tophat.jl#LL7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.TopHatCCFMask-Tuple{Real}" href="#EchelleCCFs.TopHatCCFMask-Tuple{Real}"><code>EchelleCCFs.TopHatCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor for returning constant for any Δv &lt;= width.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/tophat.jl#LL47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.TopHatCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}" href="#EchelleCCFs.TopHatCCFMask-Tuple{RvSpectMLBase.AbstractInstrument}"><code>EchelleCCFs.TopHatCCFMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>TopHatCCFMask( inst  )</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/mask_shapes/tophat.jl#LL21">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{AbstractLineList}" href="#Base.length-Tuple{AbstractLineList}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return length of line list. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/line_list/types.jl#LL87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_covar_chunk!-Union{Tuple{PlanT}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractMatrix{T2}, RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractVector{T1}, AbstractMatrix{T2}, RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_ccf_and_covar_chunk!-Union{Tuple{PlanT}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractMatrix{T2}, RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{AbstractVector{T1}, AbstractMatrix{T2}, RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_ccf_and_covar_chunk!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_covar_chunk!( chunk, ccf_plan )</code> Convenience function to compute CCF and covariance of each pair of &quot;CCF pixels&quot; for one chunk of spectrum, evaluated using mask<em>shape and line list from `ccf</em>plan`.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>ccf_covar_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>var</code>:  <code>AbstractArray</code> with variance to use for each pixel (overides value in chunk)</li><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Returns Named Tuple with:</strong></p><ul><li><code>ccf_out</code>:</li><li><code>ccf_covar_out</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunk.jl#LL52-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_covar_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_ccf_and_covar_chunk-Union{Tuple{RvSpectMLBase.AbstractChunkOfSpectrum}, Tuple{PlanT}, Tuple{T}, Tuple{RvSpectMLBase.AbstractChunkOfSpectrum, PlanT}} where {T&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_ccf_and_covar_chunk</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_covar_chunk( chunk, ccf_plan )</code> Convenience function to compute CCF and covariance of each pair of &quot;CCF pixels&quot; for one chunk of spectrum, evaluated using mask<em>shape and line list from `ccf</em>plan`.</p><p><strong>Inputs:</strong></p><ul><li><code>ccf_out</code>:  <code>AbstractArray</code> to store output</li><li><code>ccf_covar_out</code>:  <code>AbstractArray</code> to store output</li><li><code>chunk</code>: ChunkOfSpectrum to compute CCF for</li><li><code>ccf_plan</code>: for now, just a BasicCCFPlan that provides line<em>list, mask</em>shape and other parameters for calculating CCF</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>var</code>:  <code>AbstractArray</code> with variance to use for each pixel (overides value in chunk)</li></ul><p><code>-</code>assume<em>sorted`:  if true, skips checking the line</em>list is sorted by wavelength</p><p><strong>Returns Named Tuple with:</strong></p><ul><li><code>ccf_out</code>:</li><li><code>ccf_covar_out</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunk.jl#LL139-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_covar_chunklist!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractMatrix{T2}, RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where {T1&lt;:Real, T2&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_ccf_and_covar_chunklist!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractMatrix{T2}, RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where {T1&lt;:Real, T2&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_ccf_and_covar_chunklist!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_covar_chunklist! ( ccf_out, ccf_cocovar_out, chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunklist.jl#LL141-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_covar_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where PlanT&lt;:AbstractCCFPlan" href="#EchelleCCFs.calc_ccf_and_covar_chunklist-Union{Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where PlanT&lt;:AbstractCCFPlan"><code>EchelleCCFs.calc_ccf_and_covar_chunklist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_covar_chunklist ( chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunklist.jl#LL180-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_and_var_chunklist!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}, RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where {T1&lt;:Real, T2&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_ccf_and_var_chunklist!-Union{Tuple{PlanT}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{T2}, RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where {T1&lt;:Real, T2&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_ccf_and_var_chunklist!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_and_var_chunklist! ( ccf_out, ccf_var_out, chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunklist.jl#LL102-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_ccf_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractVector{T1}, RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where {T1&lt;:Real, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.calc_ccf_chunklist!-Union{Tuple{PlanT}, Tuple{T1}, Tuple{AbstractVector{T1}, RvSpectMLBase.AbstractChunkList, AbstractVector{PlanT}}} where {T1&lt;:Real, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.calc_ccf_chunklist!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_ccf_chunklist! ( ccfs_out, chunklist, ccf_plans )</code> Convenience function to compute CCF based on a spectrum&#39;s chunklist.</p><p><strong>Inputs:</strong></p><ul><li>chunklist</li><li>vector of ccf plans (one for each chunk)</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>assume_sorted</code>:  if true, skips checking the line_list is sorted by wavelength</li></ul><p><strong>Return:</strong></p><p>CCF summed over all chunks in a spectrum&#39;s chunklist, evaluated using the line list and mask_shape from the ccf plan for each chunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/ccf_chunklist.jl#LL38-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_doppler_factor-Tuple{Real}" href="#EchelleCCFs.calc_doppler_factor-Tuple{Real}"><code>EchelleCCFs.calc_doppler_factor</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_doppler_factor(vel)</code>` Compute the longitudinal relativistic doppler factor given a velocity in meters per second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/physics.jl#LL12-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccf_and_var_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{T}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries, PlanT}} where {PlanT&lt;:AbstractCCFPlan, T&lt;:Real}" href="#EchelleCCFs.calc_order_ccf_and_var_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{T}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries, PlanT}} where {PlanT&lt;:AbstractCCFPlan, T&lt;:Real}"><code>EchelleCCFs.calc_order_ccf_and_var_chunklist_timeseries</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccf_and_var_chunklist_timeseries( chunklist_timeseries, ccf_plan )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) of each spectrum in a timeseries.     CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk. Uses multiple threads if avaliable.</p><p><strong>Inputs:</strong></p><ul><li>chunklist_timeseries</li></ul><p><strong>Optional Arguments:</strong></p><ul><li>ccf_plan (BasicCCFPlan())</li></ul><p><strong>Return:</strong></p><p>A 3-d array containing the CCF at each (velocity, chunk, spectrum) Note that the ccf<em>plan provided is used as a template for creating a custom ccf</em>plan for each chunk that     only includes lines that reliably appear in that order for all spectra in the chunklist_timeseries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/order_ccf_chunklist_timeseries.jl#LL105-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.calc_order_ccf_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{T}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries, PlanT}} where {PlanT&lt;:AbstractCCFPlan, T&lt;:Real}" href="#EchelleCCFs.calc_order_ccf_chunklist_timeseries-Union{Tuple{RvSpectMLBase.AbstractChunkListTimeseries}, Tuple{T}, Tuple{PlanT}, Tuple{RvSpectMLBase.AbstractChunkListTimeseries, PlanT}} where {PlanT&lt;:AbstractCCFPlan, T&lt;:Real}"><code>EchelleCCFs.calc_order_ccf_chunklist_timeseries</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>calc_order_ccf_chunklist_timeseries( chunklist_timeseries, ccf_plan )</code> Convenience function to compute separate CCFs for each chunk (potentially an order or view around one or two lines) of each spectrum in a timeseries.     CCF is evaluated using line list and mask_shape provided by the ccf plan for each chunk. Uses multiple threads if avaliable.</p><p><strong>Inputs:</strong></p><ul><li>chunklist_timeseries</li></ul><p><strong>Optional Arguments:</strong></p><ul><li>ccf_plan (BasicCCFPlan())</li></ul><p><strong>Return:</strong></p><p>A 3-d array containing the CCF at each (velocity, chunk, spectrum) Note that the ccf<em>plan provided is used as a template for creating a custom ccf</em>plan for each chunk that     only includes lines that reliably appear in that order for all spectra in the chunklist_timeseries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/convenience/order_ccf_chunklist_timeseries.jl#LL8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.find_overlapping_chunks-Tuple{DataFrames.DataFrame}" href="#EchelleCCFs.find_overlapping_chunks-Tuple{DataFrames.DataFrame}"><code>EchelleCCFs.find_overlapping_chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return indices of any chunks in df that have overlapping <code>lambda_hi[i]</code> and <code>lambda_lo[i+1]</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/masks/masks.jl#LL70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.fit_ccf_normalizations-Union{Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1, A2}} where {T1&lt;:Real, A1&lt;:AbstractVector{T1}, T2&lt;:Real, A2&lt;:AbstractMatrix{T2}}" href="#EchelleCCFs.fit_ccf_normalizations-Union{Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A1, A2}} where {T1&lt;:Real, A1&lt;:AbstractVector{T1}, T2&lt;:Real, A2&lt;:AbstractMatrix{T2}}"><code>EchelleCCFs.fit_ccf_normalizations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>calc<em>normalized</em>ccfs( ccfs ) Normalizes each spectrum by fitting a line to the region outside the center</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/ccf_template.jl#LL8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.merge_chunks-Tuple{DataFrames.DataFrame}" href="#EchelleCCFs.merge_chunks-Tuple{DataFrames.DataFrame}"><code>EchelleCCFs.merge_chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return DataFrame with specifications for each chunk which will contain one or more lines. Input:  <code>line_list</code> a DataFrame with:     - <code>lambda_lo</code>, <code>lambda_hi</code>, <code>lambda</code>, <code>depth</code>     Output:  DataFrame with     - <code>lambda_lo</code> &amp; <code>lambda_hi</code>: boundaries for chunk     - <code>lambda</code> &amp; <code>line_depths</code>: arrays with info about each line</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/masks/masks.jl#LL84-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.project_mask!-Union{Tuple{PlanT}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A2, A1, PlanT}} where {T1&lt;:Real, A1&lt;:AbstractVector{T1}, T2&lt;:Real, A2&lt;:AbstractMatrix{T2}, PlanT&lt;:AbstractCCFPlan}" href="#EchelleCCFs.project_mask!-Union{Tuple{PlanT}, Tuple{A2}, Tuple{T2}, Tuple{A1}, Tuple{T1}, Tuple{A2, A1, PlanT}} where {T1&lt;:Real, A1&lt;:AbstractVector{T1}, T2&lt;:Real, A2&lt;:AbstractMatrix{T2}, PlanT&lt;:AbstractCCFPlan}"><code>EchelleCCFs.project_mask!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>project_mask!( output, λs, ccf_plan; shift_factor )</code></p><p>Compute the projection of the mask onto the 1D array of wavelengths (λs) at a given shift factor (default: 1). The mask is computed from the ccf<em>plan, including a line</em>list and mask<em>shape (default: tophat). Assumes plan.line</em>list is already sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/ccf/calc_ccf.jl#LL304-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.read_linelist_espresso-Tuple{String}" href="#EchelleCCFs.read_linelist_espresso-Tuple{String}"><code>EchelleCCFs.read_linelist_espresso</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Read line list in ESPRESSO csv format.</code></pre><p>ESPRESSO format: lambda and weight. convert<em>air</em>to_vacuum determines whether to convert to vacuum wavelengths. Warning: ESPRESSO masks don&#39;t provide line depth and sometimes include one entry for a blend of lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/masks/io.jl#LL8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.read_linelist_rvspectml-Tuple{String}" href="#EchelleCCFs.read_linelist_rvspectml-Tuple{String}"><code>EchelleCCFs.read_linelist_rvspectml</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read line list in csv format.    format: lambda, weight, lambda<em>lo, lambdaa</em>hi.    Assumes air to vacuumb wavelength conversion has already been applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/masks/io.jl#LL39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.read_linelist_vald-Tuple{String}" href="#EchelleCCFs.read_linelist_vald-Tuple{String}"><code>EchelleCCFs.read_linelist_vald</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read line list in VALD csv format.    VALD format: lambda<em>lo, lambdaa</em>hi and depth.    convert<em>air</em>to_vacuum determines whether to convert to vacuum wavelengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/masks/io.jl#LL24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.read_mask_espresso-Union{Tuple{String}, Tuple{CCWT}} where CCWT&lt;:EchelleCCFs.AbstractCalcChunkWidth" href="#EchelleCCFs.read_mask_espresso-Union{Tuple{String}, Tuple{CCWT}} where CCWT&lt;:EchelleCCFs.AbstractCalcChunkWidth"><code>EchelleCCFs.read_mask_espresso</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Read mask in ESPRESSO csv format.</code></pre><p>ESPRESSO format: <code>lambda</code> and <code>weight</code>. Warning: ESPRESSO masks don&#39;t provide line depth and sometimes include one entry for a blend of lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/masks/masks.jl#LL39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.read_mask_vald-Union{Tuple{String}, Tuple{CCWT}} where CCWT&lt;:EchelleCCFs.AbstractCalcChunkWidth" href="#EchelleCCFs.read_mask_vald-Union{Tuple{String}, Tuple{CCWT}} where CCWT&lt;:EchelleCCFs.AbstractCalcChunkWidth"><code>EchelleCCFs.read_mask_vald</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read mask in VALD csv format.    VALD format: <code>lambda_lo</code>, <code>lambdaa_hi</code> and <code>depth</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/masks/masks.jl#LL55-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.λ_air_to_vac-Tuple{Real}" href="#EchelleCCFs.λ_air_to_vac-Tuple{Real}"><code>EchelleCCFs.λ_air_to_vac</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert air wavelength (in Å) to vacuum wavelength Ref: https://www.astro.uu.se/valdwiki/Air-to-vacuum%20conversion      VALD3 tools use the following solution derived by N. Piskunov</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/physics.jl#LL39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EchelleCCFs.λ_vac_to_air-Tuple{Real}" href="#EchelleCCFs.λ_vac_to_air-Tuple{Real}"><code>EchelleCCFs.λ_vac_to_air</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert vacuum wavelength (in Å) to air wavelength Ref: Donald Morton (2000, ApJ. Suppl., 130, 403) via      https://www.astro.uu.se/valdwiki/Air-to-vacuum%20conversion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RvSpectML/EchelleCCFs.jl/blob/f12ced6b2af85830bbe7c0d259afff235fdea9c8/src/physics.jl#LL28-L32">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../calc_rv/">Calculate RVs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Sunday 26 June 2022 04:22">Sunday 26 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
